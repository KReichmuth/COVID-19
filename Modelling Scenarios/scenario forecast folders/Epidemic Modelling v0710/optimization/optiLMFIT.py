from optimization.params_flattenerunflattener import params_flatten, params_unflatten
from optimization.optiBase import optiBase
from lmfit import minimize, Parameters, report_fit


class optiLMFIT(optiBase):

    def inject_parameters_into_model(self, parameters):
        '''
        Function exploited to inject optimization parameters generated by the optimization algorithm into the model.
        Takes into account the fact that parameters data structures have to be flattened-unflattened based on the
        requirements of library LMFIT. The flattening-unflattening cycle works as follows: get params to be optimized
        from the model => flatten their data structure => inject into LMFIT parameters => [iteratively during
        solution and when optimum is found] unflatten parameters produced by the optimization algorithm and inject in
        the model, et cetera.
        '''
        # get flat dict of optimization parameters set by the optizer
        for tag in self.params_flattened_retagged.keys():
            self.params_flattened_retagged[tag] = parameters[tag].value
        # reconvert keys format (strrep was introduced for parameterization consistently with LMFIT requirements)
        params_flattened = {}
        for tag in self.params_flattened_retagged.keys():
            key = tag.replace("VARIABLE", ".")
            params_flattened[key] = self.params_flattened_retagged[tag]
        # unflatten and attribute parameters to the model
        params_unflattened = params_unflatten(params_flattened)

        # set model attributes
        for key in params_unflattened.keys():
            setattr(self.model, key, params_unflattened[key])

    @property
    def parameters(self):
        '''
        Sets optimization parameters, including attributes such as bounds.
        '''

        # init
        parameters = Parameters()

        # get list of optimization parameters from the model
        params = self.model.get_optimization_variables()
        # print('params=',params)
        params_flattened = params_flatten(params)
        # print('params_flatten', params_flatten)

        # retag the flattened data structure to meet the requirements of library LMFIT
        self.params_flattened_retagged = {}
        for key in params_flattened.keys():
            tag = key.replace(".", "VARIABLE")
            self.params_flattened_retagged[tag] = params_flattened[key]

        # define optimization parameters exploiting attributes specified in model.VAR_OPTIM_ATTRIBUTES
        for key in self.params_flattened_retagged.keys():
            p = self.model.VAR_OPTIM_ATTRIBUTES[key]
            parameters.add(key, value=p["value"], min=p["min"], max=p["max"])

        return parameters

    def optim_function(self, parameters):
        '''
        Triggers the ODE-IVP solution and returns residuals.
        '''
        # todo remove
        # print(parameters)

        # inject parameters into model (=> this triggers the automated re-computation of model solutions) and return residuals
        self.inject_parameters_into_model(parameters)

        return self.residuals

    def optimize(self, optimization_method="leastsq"):
        '''
        Fits model and finds predicted values.
        '''

        # solve the optimization problem
        self.optimum = minimize(self.optim_function, self.parameters, method=optimization_method, max_nfev=5000)

        # inject the optimal solutions into the model
        self.inject_parameters_into_model(self.optimum.params)

        # print optimization outcomes report
        if self.verbose:
            report_fit(self.optimum)

    def get_optimum_parameters(self):

        optim = self.optimum.params

        optim_retagged = {}
        for tag in optim.keys():
            optim_retagged[tag.replace("VARIABLE", ".")] = optim[tag].value

        return params_unflatten(optim_retagged)
